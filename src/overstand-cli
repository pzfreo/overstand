#!/usr/bin/env python3
"""
Command-line interface for generating instrument diagrams.

Usage:
    overstand-cli input.json --view side --output diagram.svg
    overstand-cli input.json --view side --pdf
    overstand-cli input.json --view dimensions --pdf -o dims.pdf
    overstand-cli input.json --all --output-dir ./output
    overstand-cli input.json --all --pdf --output-dir ./output
"""

import argparse
import json
import re
import sys
import os
import tempfile
from pathlib import Path


# View name mappings (matching web app style)
VIEW_NAMES = {
    'side': 'side-view',
    'top': 'top-view',
    'cross_section': 'cross-section',
    'dimensions': 'dimensions'
}


def sanitize_filename(name):
    """Sanitize a string for use as a filename (matching web app behavior)."""
    # Replace special chars and spaces with underscores
    return re.sub(r'[<>:"/\\|?*\s]+', '_', name).strip('_')


def get_unique_filename(base_path):
    """Get a unique filename by adding increment if file exists."""
    path = Path(base_path)
    if not path.exists():
        return path

    stem = path.stem
    suffix = path.suffix
    parent = path.parent

    counter = 1
    while True:
        new_path = parent / f"{stem}_{counter}{suffix}"
        if not new_path.exists():
            return new_path
        counter += 1


def load_parameters(json_file):
    """Load parameters from a JSON file."""
    try:
        with open(json_file, 'r') as f:
            data = json.load(f)

        # Handle both direct parameters and wrapped format (with metadata)
        if 'parameters' in data:
            return data['parameters']
        return data
    except FileNotFoundError:
        print(f"Error: File '{json_file}' not found", file=sys.stderr)
        sys.exit(1)
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON in '{json_file}': {e}", file=sys.stderr)
        sys.exit(1)


def svg_to_pdf(svg_content, output_path):
    """Convert SVG content to PDF using svglib + reportlab."""
    try:
        from svglib.svglib import svg2rlg
        from reportlab.graphics import renderPDF
    except ImportError:
        print("Error: PDF generation requires svglib and reportlab.", file=sys.stderr)
        print("Install with: pip install svglib reportlab", file=sys.stderr)
        sys.exit(1)

    # Write SVG to temp file (svglib needs a file path)
    with tempfile.NamedTemporaryFile(mode='w', suffix='.svg', delete=False) as f:
        f.write(svg_content)
        temp_path = f.name

    try:
        # Convert SVG to reportlab drawing
        drawing = svg2rlg(temp_path)
        if drawing is None:
            print("Error: Failed to parse SVG content", file=sys.stderr)
            sys.exit(1)

        # Render to PDF
        renderPDF.drawToFile(drawing, output_path)
    finally:
        # Clean up temp file
        os.unlink(temp_path)


def html_to_pdf(html_content, output_path):
    """Convert HTML content to PDF using weasyprint."""
    try:
        from weasyprint import HTML
    except ImportError:
        print("Error: PDF generation for HTML requires weasyprint.", file=sys.stderr)
        print("Install with: pip install weasyprint", file=sys.stderr)
        sys.exit(1)

    HTML(string=html_content).write_pdf(output_path)


def generate_view(params, view_type):
    """Generate a specific view."""
    from instrument_generator import generate_violin_neck
    from instrument_geometry import generate_side_view_svg

    if view_type == 'side':
        return generate_side_view_svg(params)
    elif view_type == 'top':
        # Not implemented yet
        return '<svg><text x="10" y="20">Top view not yet implemented</text></svg>'
    elif view_type == 'cross_section':
        # Not implemented yet
        return '<svg><text x="10" y="20">Cross-section view not yet implemented</text></svg>'
    elif view_type == 'dimensions':
        # Generate dimensions table as HTML
        from parameter_registry import (
            get_parameter_categories,
            get_all_input_parameters,
            ParameterType
        )
        from instrument_geometry import calculate_derived_values

        categories = get_parameter_categories()
        input_params = get_all_input_parameters()
        derived = calculate_derived_values(params)

        html = '<!DOCTYPE html>\n<html>\n<head>\n'
        html += '<meta charset="UTF-8">\n'
        html += f'<title>{params.get("instrument_name", "Instrument")} - Dimensions</title>\n'
        html += '<style>\n'
        html += 'body { font-family: Arial, sans-serif; margin: 40px; }\n'
        html += 'h1 { color: #4F46E5; }\n'
        html += 'table { border-collapse: collapse; width: 100%; max-width: 800px; }\n'
        html += 'th { background: #4F46E5; color: white; padding: 12px; text-align: left; }\n'
        html += 'td { padding: 10px 12px; border-bottom: 1px solid #e5e7eb; }\n'
        html += 'tr:hover { background: #f9fafb; }\n'
        html += '.category-header { background: #f3f4f6; font-weight: 600; color: #374151; }\n'
        html += '.param-unit { color: #6b7280; font-size: 0.9em; font-style: italic; }\n'
        html += '</style>\n</head>\n<body>\n'
        html += f'<h1>{params.get("instrument_name", "Instrument")} - Dimensions</h1>\n'
        html += '<table>\n<thead><tr><th>Parameter</th><th>Value</th></tr></thead>\n<tbody>\n'

        for category in categories:
            if category == 'Display Options':
                continue

            html += f'<tr><td colspan="2" class="category-header">{category}</td></tr>\n'

            for name, param in input_params.items():
                # Get category from input_config
                param_category = param.input_config.category if param.input_config else None
                if param_category != category:
                    continue

                value = params.get(name)
                if value is None:
                    continue

                # Check parameter type using ParameterType enum
                if param.param_type == ParameterType.NUMERIC:
                    display_value = f'{value} <span class="param-unit">{param.unit}</span>'
                elif param.param_type == ParameterType.BOOLEAN:
                    display_value = 'Yes' if value else 'No'
                elif param.param_type == ParameterType.ENUM:
                    display_value = value
                elif param.param_type == ParameterType.STRING:
                    display_value = str(value)
                else:
                    display_value = str(value)

                html += f'<tr><td>{param.display_name}</td><td>{display_value}</td></tr>\n'

        # Add derived values
        if derived:
            html += '<tr><td colspan="2" class="category-header">Calculated Values</td></tr>\n'
            for label, value in derived.items():
                html += f'<tr><td>{label}</td><td>{value}</td></tr>\n'

        html += '</tbody>\n</table>\n</body>\n</html>'
        return html
    else:
        print(f"Error: Unknown view type '{view_type}'", file=sys.stderr)
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        description='Generate instrument diagrams from parameter files',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate side view SVG to stdout
  overstand-cli params.json --view side

  # Generate side view SVG to file
  overstand-cli params.json --view side --output side-view.svg

  # Generate side view as PDF (auto-generates filename)
  overstand-cli params.json --view side --pdf
  # → Creates: My_Violin_side-view.pdf

  # Generate dimensions table as PDF
  overstand-cli params.json --view dimensions --pdf
  # → Creates: My_Violin_dimensions.pdf

  # Generate all views in native formats (SVG, HTML)
  overstand-cli params.json --all --output-dir ./diagrams

  # Generate all views as PDFs
  overstand-cli params.json --all --pdf --output-dir ./diagrams
        """
    )

    parser.add_argument('input', help='Input JSON parameter file')
    parser.add_argument('--view', choices=['side', 'top', 'cross_section', 'dimensions'],
                        help='View type to generate')
    parser.add_argument('--pdf', action='store_true',
                        help='Output as PDF instead of native format (SVG/HTML)')
    parser.add_argument('--output', '-o',
                        help='Output file (default: auto-generate for PDF, stdout for SVG/HTML)')
    parser.add_argument('--all', action='store_true',
                        help='Generate all views (requires --output-dir)')
    parser.add_argument('--output-dir', help='Output directory for --all mode')

    args = parser.parse_args()

    # Validation
    if args.all and not args.output_dir:
        parser.error('--all requires --output-dir')
    if not args.all and not args.view:
        parser.error('Either --view or --all must be specified')
    if args.all and args.view:
        parser.error('Cannot use both --all and --view')

    # Load parameters
    params = load_parameters(args.input)
    instrument_name = sanitize_filename(params.get('instrument_name', 'instrument'))

    if args.all:
        # Generate all views
        output_dir = Path(args.output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)

        # Define views with their native formats
        views = {
            'side': ('svg', generate_view(params, 'side')),
            'dimensions': ('html', generate_view(params, 'dimensions'))
        }

        if args.pdf:
            # Generate PDF versions of all views
            for view_key, (native_ext, content) in views.items():
                view_name = VIEW_NAMES.get(view_key, view_key)
                pdf_file = output_dir / f'{instrument_name}_{view_name}.pdf'
                if native_ext == 'svg':
                    svg_to_pdf(content, str(pdf_file))
                else:  # html
                    html_to_pdf(content, str(pdf_file))
                print(f'Generated: {pdf_file}')
        else:
            # Generate native formats
            for view_key, (ext, content) in views.items():
                view_name = VIEW_NAMES.get(view_key, view_key)
                output_file = output_dir / f'{instrument_name}_{view_name}.{ext}'
                with open(output_file, 'w') as f:
                    f.write(content)
                print(f'Generated: {output_file}')
    else:
        # Generate single view
        content = generate_view(params, args.view)
        is_html = args.view == 'dimensions'
        view_name = VIEW_NAMES.get(args.view, args.view)

        if args.pdf:
            # Determine output filename
            if args.output:
                output_path = Path(args.output)
            else:
                # Auto-generate filename matching web app style
                base_filename = f"{instrument_name}_{view_name}.pdf"
                output_path = get_unique_filename(base_filename)

            # Convert to PDF
            if is_html:
                html_to_pdf(content, str(output_path))
            else:
                svg_to_pdf(content, str(output_path))
            print(f'Generated: {output_path}')
        elif args.output:
            # Write to file
            with open(args.output, 'w') as f:
                f.write(content)
            print(f'Generated: {args.output}')
        else:
            # Print to stdout
            print(content)


if __name__ == '__main__':
    main()
